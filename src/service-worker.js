/* eslint-disable no-restricted-globals */
/* global clients */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules/workbox-sw
// for more information on how to use workbox-sw.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (fileExtensionRegexp.test(url.pathname)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year.
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  })
);

// Cache audio files
registerRoute(
  ({ request }) => request.destination === 'audio',
  new CacheFirst({
    cacheName: 'audio-files',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        maxEntries: 10,
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        maxEntries: 50,
      }),
    ],
  })
);

// Background media playback handler
self.addEventListener('fetch', (event) => {
  // Check if this is a range request for audio
  if (event.request.headers.has('range')) {
    const url = new URL(event.request.url);
    const extension = url.pathname.split('.').pop();
    
    if (extension === 'mp3' || extension === 'wav' || extension === 'ogg') {
      event.respondWith(
        caches.open('audio-files').then(async (cache) => {
          // Get the full audio file from the cache
          const cacheResponse = await cache.match(
            new Request(event.request.url, { headers: {} })
          );
          
          if (!cacheResponse) {
            // If not in cache, fetch it
            return fetch(event.request);
          }
          
          // Clone the response so we can modify it
          const response = cacheResponse.clone();
          
          // Get the range header value
          const rangeHeader = event.request.headers.get('range');
          const rangeMatch = rangeHeader.match(/bytes=(\d+)-(\d+)?/);
          const pos = Number(rangeMatch[1]);
          const end = rangeMatch[2] ? Number(rangeMatch[2]) : response.clone().blob().size - 1;
          const newResponse = await response.slice(pos, end + 1);
          
          // Return a ranged response
          return new Response(newResponse, {
            status: 206,
            statusText: 'Partial Content',
            headers: {
              'Content-Type': response.headers.get('Content-Type'),
              'Content-Range': `bytes ${pos}-${end}/${response.clone().blob().size}`,
              'Content-Length': String(end - pos + 1),
            },
          });
        }).catch(() => {
          return fetch(event.request);
        })
      );
    }
  }
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Automatic service worker update check
const CACHE_VERSION = '1.0.2'; // Update this when you want to force cache refresh

self.addEventListener('install', (event) => {
  // Skip waiting to activate immediately
  self.skipWaiting();
  
  // Clear old caches when installing new version
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          // Only clear our app caches, not external ones like Google Fonts
          if (cacheName.startsWith('workbox-precache') || 
              cacheName.includes('audio-files') || 
              cacheName.includes('images')) {
            return caches.delete(cacheName);
          }
          return Promise.resolve();
        })
      );
    })
  );
});

self.addEventListener('activate', (event) => {
  // Take control of all clients immediately
  event.waitUntil(clients.claim());
  
  // Notify all clients that a new version is available
  event.waitUntil(
    clients.matchAll().then(clients => {
      clients.forEach(client => {
        client.postMessage({
          type: 'NEW_VERSION_AVAILABLE',
          version: CACHE_VERSION
        });
      });
    })
  );
});

// Any other custom service worker logic can go here.

// Add cache control headers to prevent stale content
self.addEventListener('fetch', event => {
  // Skip cross-origin requests
  if (event.request.url.startsWith(self.location.origin)) {
    // Only handle HTML requests for the root page
    if (event.request.url.endsWith('/') || event.request.url.endsWith('/index.html')) {
      event.respondWith(
        fetch(event.request)
          .then(response => {
            // Clone the response to modify headers
            const newResponse = new Response(response.body, response);
            
            // Add no-cache headers to force fresh content
            newResponse.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
            newResponse.headers.set('Pragma', 'no-cache');
            newResponse.headers.set('Expires', '0');
            
            return newResponse;
          })
          .catch(() => {
            // Fallback to cache if network fails
            return caches.match(event.request);
          })
      );
    }
  }
});